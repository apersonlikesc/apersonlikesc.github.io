<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux From Scrach 1]]></title>
    <url>%2F2018%2F07%2F12%2Flfs1%2F</url>
    <content type="text"><![CDATA[准备准备空间大概8g 准备在u盘上构建系统我准备将u盘对半分成两个盘一个安装系统,就用ext4一个当作普通的u盘来用记得分区的时候格式化可以使用fdisk 或者 其他工具 另外: 我的arch上没有创建swap分区 挂载U盘/移动硬盘使用fdisk -l命令得到123456789Disk /dev/sdb：29 GiB，31104958464 字节，60751872 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0xcad4ebea设备 启动 起点 末尾 扇区 大小 Id 类型/dev/sdb4 * 63 60751871 60751809 29G c W95 FAT32 (LBA) 创建文件夹 将sdb4挂载到文件夹上 一般u盘会自动挂载,像我的系统就是挂载到run/s/xxx 下面不过官方建议还是挂载到 /mnt/lfs 下面 mount -v -t ext4 /dev/&lt;xxx&gt; $LFS # 将 /dev/ 挂载到 $LFS 如果重启设备，可能进入后发现 /mnt/lfs 目录下没有内容，这是只需要再次挂载 /dev/ 到 /mnt/lfs。 此处 用实际的设备名称代替 这里我只使用一个 / 分区 如果 LFS 使用了多个分区，(比如：一个 /，一个 /usr)，用下面的命令挂载它们： 1234mkdir -pv $LFS # 建立 / 分区的挂载点mount -v -t ext4 /dev/&lt;xxx&gt; $LFS # 将 /dev/&lt;xxx&gt; 挂载到 $LFSmkdir -v $LFS/usr # 建立 $LFS/usr 挂载点，用于挂载 /usrmount -v -t ext4 /dev/&lt;yyy&gt; $LFS/usr # 将 /dev/&lt;yyy&gt; 挂载到 $LFS/usr 附:如果你正在使用交换分区，用 swapon 命令确保它已经启用。 /sbin/swapon -v /dev/&lt;zzz&gt;用 swap 分区的名字替换。 注意:确保你的 echo $LFS 在root与用户帐号上时/mnt/lfs 你可以使用全局变量来设置 软件包和补丁mkdir -v $LFS/sources在$lfs里创建sources文件夹 来存放 下载好的软件包和补丁 设置目录的写权限和粘滞模式。“粘滞模式”意思是就算有多个用户对某个目录有写权限，仍然只有该文件的主人能删除一个粘滞目录里的文件。下面的命令可以打开写权限和粘滞模式：chmod -v a+wt $LFS/sources 下载软件包可以去中科院镜像里面去下载里面已经有了md5sums 解压放到source里面就行下载完成后使用md5sums检验====&gt;将下载的md5sums 放到sources目录下 123pushd $LFS/sourcesmd5sum -c md5sumspopd 最后的准备工作 我们还需要为构建临时系统做一些额外的准备工作。我们会在 $LFS 中新建一个文件夹用于临时工具的安装，增加一个非特权用户用于降低风险，并为该用户创建合适的构建环境。我们也会解释用于测量构建 LFS 软件包花费时间的单位，或者称为“标准编译单位（SBU）”，并给出一些关于软件包测试套件的信息 以 root 用户运行以下的命令来创建需要的文件夹：mkdir -v $LFS/tools 下一步是在宿主系统中创建 /tools 的符号链接，将其指向 LFS 分区中新建的文件夹。同样以 root 用户运行下面的命令： ln -sv $LFS/tools / 添加 LFS 用户当以 root 用户登录时，犯一个小错误可能会破坏或摧毁整个系统。因此，我们建议在本章中以非特权用户编译软件包。你可以使用你自己的用户名，但要容易的话，就建立一个干净的工作环境，创建一个名为 lfs 的新用户作为新组（名字也是 lfs ）的成员，并在安装过程中使用这个用户。以 root 用户运行以下命令来添加新用户：12groupadd lfsuseradd -s /bin/bash -g lfs -m -k /dev/null lfs 12345678910111213命令行选项的意思：-s /bin/bash把 bash 设置为 lfs 用户的默认 shell。-g lfs这个选项将用户 lfs 添加到组 lfs 中。-m为 lfs 用户创建主目录。-k /dev/null这个参数通过改变输入位置为特殊的空（null）设备，以防止可能从一个模版目录中（默认是 /etc/skel）复制文件。 lfs这是创建的组和用户的实际名称。 要以 lfs 用户身份登录（以 root 身份登录切换到 lfs 用户时不要求 lfs 用户设置了密码），需要给 lfs 用户一个密码：passwd lfs 通过更改文件夹所有者为 lfs，为用户 lfs 赋予了访问 $LFS/tools 文件夹的所有权限： chown -v lfs $LFS/tools 如果正如建议的一样创建了一个单独的工作目录，给 lfs 用户赋予这个文件夹的所有权：chown -v lfs $LFS/sources 下一步，以 lfs 用户身份登录。可以能通过一个虚拟控制台、显示控制器，或者下面的切换用户命令完成：su - lfs 设置环境123cat &gt; ~/.bash_profile &lt;&lt; &quot;EOF&quot;exec env -i HOME=$HOME TERM=$TERM PS1=&apos;\u:\w\$ &apos; /bin/bashEOF 当以 lfs 用户身份登录时，初始 shell 通常是一个可登录的 shell，它先读取宿主机的 /etc/profile文件（很可能包括一些设置和环境变量），然后是 .bash_profile 文件。.bash_profile 文件中的exec env -i.../bin/bash 命令用一个除了 HOME、TERM和 PS1 变量，完全空环境的 shell 代替运行中的 shell。这可以确保没有不必要的或者有潜在风险的环境变量从宿主机系统中泄露到构建环境。这里使用的技巧是为了有一个干净环境。 新的 shell 实例是一个非登录 shell，不会读取 /etc/profile 或者 .bash_profile文件，而是读取 .bashrc文件。 现在创建 .bashrc 文件：123456789cat &gt; ~/.bashrc &lt;&lt; &quot;EOF&quot;set +humask 022LFS=/mnt/lfsLC_ALL=POSIXLFS_TGT=$(uname -m)-lfs-linux-gnuPATH=/tools/bin:/bin:/usr/binexport LFS LC_ALL LFS_TGT PATHEOF set +h命令关闭了 bash的哈希功能。 哈希通常是一个有用的功能，bash 用一个哈希表来记录可执行文件的完整路径，以避免搜索PATH 的时间和又找到一个相同的可执行文件。然而，新工具要一安装后就使用。通过关闭哈希功能，一个程序准备运行时 shell 总是会搜索PATH变量。如此，shell 能在新编译的工具可用时马上在文件夹 $LFS/tools 中找到，而不是记录相同程序在其它地方的之前版本。 设置用户文件新建掩码（umask）为 022，确保新建的文件和目录只有它们自己的所有者可写，任何人都可读和可执行(假定open(2) 系统调用使用的默认模式是新文件使用 644模式，文件夹使用755模式)。 LFS 变量应该设置为选定的挂载点。 LC_ALL 变量控制特定程序的本地化，使得它们的消息能遵循特定国家的惯例。设置 LC_ALL 为 “POSIX” 或 “C”（两者是等价的），确保 chroot 环境中一切如期望的那样进行。 当编译我们的交叉编译器和链接器以及交叉编译我们的临时工具链时，LFS_TGT变量设置了一个非默认，但兼容的机器说明。5.2,“工具链技术说明”包含更多的信息。 把 /tools/bin 放在标准的 PATH 变量前面， 第五章中安装的软件一安装完成 shell 就可使用。这和关闭哈希功能一起，降低了在第五章环境中新程序可用时宿主机器使用旧程序的风险。 生效配置文件:source ~/.bash_profile 关于 SBUSBU 衡量方式如下。我们以第五章编译的第一个软件包 Binutils 所用时间作为一个标准编译单位（SBU），其它软件的生成时间都以其为标准进行比较。 例如，假如编译一个软件耗时 4.5 SBU，而编译安装初代 Binutils 用时 10 分钟的话，那么编译这个软件包大约耗时 45 分钟。当然啦，对于大多数人来说，编译 Binutils 可用不了 10 分钟那么久。 在一些情况下，使用多处理器同时编译可能失败，分析错误日志变得异常困难：因为不同处理器之间的执行路线是交错的。如果你在编译的时候遇到问题，那么请回过来使用单处理器编译，以正确地查看错误消息。 构建临时系统目标是生成一个临时的系统，它包含一个已知的较好工具集，该工具集可与宿主系统分离。通过使用 chroot，其余各章中的命令将被包含在此环境中，以保证目标 LFS 系统能够洁净且无故障地生成。该构建过程的设计就是为了使得新读者有最少的风险，同时还能有最好的指导价值。 最后确认一次是否正确设置了 LFS 环境变量：echo $LFS确认输出显示的是 LFS 分区挂载点的路径，在我们的例子中也就是 /mnt/lfs。 最后，必须强调两个重要的点： [重要] 重要 编译指南假定你已经正确地设置了宿主系统需求和符号链接： shell使用的是 bash。 sh 是到 bash的符号链接。 /usr/bin/awk 是到 gawk的符号链接。 /usr/bin/yacc 是到bison的符号链接或者一个执行 bison 的小脚本。 [重要] 重要 再次强调构建过程： 把所有源文件和补丁放到 chroot 环境可访问的目录，例如 /mnt/lfs/sources/。但是千万不能把源文件放在 /mnt/lfs/tools/ 中。 进入到源文件目录。 对于每个软件包: 用 tar 程序解压要编译的软件包。在第五章中，确保解压软件包时你使用的是 lfs 用户。2. 进入到解压后创建的目录中。4. 根据指南说明编译软件包。6. 回退到源文件目录。8. 除非特别说明，删除解压出来的目录和所有编译过程中生成的 &lt;package>-build 目录。 这里我在使用lfs帐号进入lfs文件夹的时候出现了权限不足,我使用了chmod加了权限 之后就是漫长的编译过程具体按照官方资料上进行编译 中文资料(已过期7.7)https://linux.cn/lfs/LFS-BOOK-7.7-systemd/index.html 英文资料(目前时8.2)http://www.linuxfromscratch.org/lfs/view/stable/index.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git443错误]]></title>
    <url>%2F2018%2F07%2F11%2Fgit443%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[在git push的时候出现OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 网上的解决方法都不管用 解决方法: 换网络,连上手机热点,成功 =.=]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>443错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git上传脚本]]></title>
    <url>%2F2018%2F07%2F11%2Fgit%E4%B8%8A%E4%BC%A0%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[由于上传命令太多了,所以写了脚本命名为comgit12#!/bin/bashgit add --all;git commit -m &quot;$1&quot;;git pull;git push; 使用方法 comgit &quot;comment&quot;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python脚本基础]]></title>
    <url>%2F2018%2F07%2F10%2Fpython%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数组类型tuple字典类型dict使用*tuple解析数组使用**dict解析字典传参数的时候 单个字符,数字由*args接受,形成tuple键值对有**kwargs接受,形成dict主函数if __name__ == &#39;__main__&#39;当然也可以使用sys.argv来读取参数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell基础]]></title>
    <url>%2F2018%2F07%2F10%2Fshell%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[shell开头12345#!/bin/bash#!/bin/sh#!/usr/bin/awk#!/usr/bin/env python#!/usr/bin/perl 这几行在第一行,不再第一行就是注释不用的话就用相关解释器带上文件名执行在写脚本的时候如果不加前面的也会交给bash解释,但是还是指定解释器比较好 注意点一定义变量名的时候等号旁边没有空格 要在登录后显示初始化内容可以将脚本文件放到 /etc/profile.d/ 的下面或者是更改/etc/motd 文件 单引号中`` 命令无效 当参数大于9个要使用${}方式 touch 主要是用来更新时间的…. 使用cat连接两个文件 ln -s 源文件 快捷方式 s表示链接 有多个命令就使用;号,若将输出全都重定向用{}扩起来,{}是父shell,()是子shell 注意点二12345678read读到换行符为止,所以就使用循环可以将文件读完,不然好像只能读一行黑洞/dev/null 了解一下-.-cp mv rm 加上-i 进行确认`command` == $(command)`read file` 是要求用户输入并且保存到file变量中...`read -p &quot;&quot; ver `就像scanf一样..(我下所的)readonly xxx=1 或者readonly xxx(已定义) 表示只读无法改变包括unset用重定向代替输入 shell中0给了stdin 1给了stdout 2给了stderr 其余数字可以来关联输出文件 例如文件中&gt;&amp;3 命令用3&gt;文件 输出到文件中 exec 将文件关联paste两个文件连接tr替换if空格[] while空格: expand unexpand 将tab 转换成空格 一般只早开头 使用-a 替换全部 unset 消除定义的变量 ${array[*]} == ${array[@]} “”${array[*]} != “${array[@]}”前面是整个数组的字符串,后面时整个数组 123456789条件语句if or elif 后面要跟上 then 如:if [ xx ]then xxxxxelif [ xxx ]then xxxxxfi 12345678[ ]是shell的内置命令 下列给出操作符:-eq equal to-ne not equal to-lt less than-gt great thange (没有-哦) great or equal如果条件判断与then写在统一行then前面加;[]两侧要有空格 注意点三 在case中 中止case语句用;;如果用;&amp; or ;;&amp;来终止还是执行下去,他中止的是子句,会使用word在去匹配pattern,直到遇到;;结束case递增可以使用let x=$x+1 当然也可以使用expr语句-.-我也是随机选择的….do 和while [ ]写在一起的时候do前面有分号while 后面可以加上命令list 使用分号;来隔开,决定是否推出循环的是最后一个命令返回值,注意是最后一个!!!其中命令都是用[]扩起来的列入[];[];[][] 是条件-n String 判断字符串长度是否非0-z Stirng 判断字符串长度为0时就断(zero)String=StringString!=String 1234567for 后面不加in就选择传入的参数同时也可以写的像c的for一样但是写成要这样for((p=1,k=321;p&lt;10;p++,k++))do xxxxxdone 1234select var in xxx xxx xxx xxxdo xxxx(可以是case或者是if条件判断)done 在select中要写退出循环的条件,不然会一直循环下去,还有就是要写其他选项的条件,不然不科学-.- option 参数的代码123456while getopts x:x:x: OPTION 这个option可以随便定义do case $OPTION in x) xxx=$OPTAGE;; 这个变量时规定的 与$REPLY一样done 写的函数可以直接调用 条件中-r 可读 -w 可写 -a and12345$&#123;xx:-dsa&#125;等:(也可以通过其他方式来实现) :-先默认后赋值,不改变 :+先赋值,不改变 :=改变 :?若是空的则输出错误退出脚本 $PAGER 似乎是系统变量 显示文档的less也可以通过其他方式来实现 echo -n 不换行输出 -e 激活转移字符 sort -u 忽略相同行 当不能使用管道时可以使用命令替代参数 数字或者字符串expression不能出现在$()中,要用()扩起来后在放到$()中间…… 循环的话要注意变量的赋值 find 命令 从给定的文件位置开始找 -iname 忽略大小写-mtime 表示修改时间 -mtime n修改时间为n天-mtime +n 大于n天-mtime -n 小于n天 如果有多个命令使用-a来连接 其中如果有()要使用\ 来转义 -o 或者 xargs 可以处理很多参数 locate 查询本地的数据库 find是直接查找文件系统 dd if=file of=file count=blocks bs=bytes 信号 通过trap xx(函数名) 数字 可以将让函数才该信号出现的时候调用该函数使用trap也可以脚本结束后调用函数,数字是0使用’’ 或者: 是屏蔽中断INT信号使用trap INT 来恢复exit xx 中xx是信号kill 进程的时候要先kill掉子进程,不然会交给init进程接管使用&amp;&amp;连接多个命令的时候是一个一个执行的,会创建子bash执行进程 command|sed &#39;command&#39;sed &#39;command&#39; file 使用;分号来连接多个command(不用另起’’) 或者使用-e(要’’分离每个命令)也可以将多个command写在一个文件中,-f指定文件!可以对取值范围取反sed stream editor 可以从管道或者文件中读取参数 sed -n &#39;1~2p&#39; 1 start 2 step sed还能加上正则/^$/使用正则还能代替行号使用&amp;表示正则表达式获取的结果 awk ‘script’ files12345678910&apos;script&apos; 中一般为 /pattern/&#123;action&#125; exprssion &#123;action&#125;其中特殊的有: value ~ /pattern/ 与正则匹配 加个!就是不匹配 可以使用()将判断分离,这样()间可以使用||或者&amp;&amp;链接分割符通过-F指定可以在awk文件中写好命令之后使用-f来指定文件使用BEGIN&#123;&#125;来执行处理数据之前执行的初始化操作使用next来表示 将两个命令的结果连接起来 #!/bin/bash/awk -f awk脚本 .awk awk中有内建变量 NR为行数 FS分割符 等等]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim基础]]></title>
    <url>%2F2018%2F07%2F10%2Fvim%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ctrl + s 卡死后使用 ctrl + q z回车 将光标所在行移动到屏幕顶端 z. 将光标所在行移动到屏幕中间 z- 将光标所在行移动到屏幕低端]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql基本知识]]></title>
    <url>%2F2018%2F07%2F10%2Fsql%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[当我在将大小写忽略的时候之前使用大写的数据库的名字就进不去了,因为系统自动将我打的大写换成了小写….. 每一个检查点都会记录他自己的操作对象的信息状态,当共用的是同一个硬盘上的数据,硬盘上的数据是会被最近的检查点所覆盖掉的,当要回复在之前的某一个特定的检查点的时候,是先通过最近的检查点来逐级向上恢复的]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2F2018%2F07%2F10%2Fgit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一般提交操作为:1234git add -all ==&gt; gaagit commit -m &quot;xxxx&quot; ==&gt; gcgit pull ==&gt; glgit push ==&gt; gp 自动保存密码:git config --global credential.helper store]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css渐变动画]]></title>
    <url>%2F2018%2F07%2F10%2Fcss%E6%B8%90%E5%8F%98%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[鼠标放上去渐变12345678div&#123;width:100px;transition: width 2s;-moz-transition: width 2s; /* Firefox 4 */-webkit-transition: width 2s; /* Safari 和 Chrome */-o-transition: width 2s; /* Opera */&#125; 使div居中:要设置div的宽度 再使用margin 0 auto设置]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>渐变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于pacman]]></title>
    <url>%2F2018%2F07%2F10%2Fpacman%2F</url>
    <content type="text"><![CDATA[pacman -D --asexplicite xxx 设置为单独安装的包 pacman -Qtd 出来的包可以删 但有些删除可能会有影响,大多没用 pacman -Rscn 可以删除干净包 pacman -Rdd 是在出现了依赖问题的时候用用,一般就不用它,他是强行破坏 依赖关系 有些依赖关系不一定会长久存在,所以pacman -Qtd不是删除干净包就一定没有东西的 可能会在你装包的时候出现依赖的更新 pacman不会自动帮你删除孤包 Rdd所操作的对象往往是这个包同时被其他的包依赖， 如果你正常情况下用R去卸它是会报错提示破坏依赖的。 比如一条依赖树a-b-c，即c依赖b，b又依赖a， 那么如果你用R或者Rs去卸载b就会报错提示你c的依赖将被破坏所以不能卸。 如果是用Rdd卸载b就是不管谁依赖它就是强行把b一个东西删掉， 本质上是临时破坏一下依赖。这个做法往往是出了什么问题才会用的。 卸载同时删配置文件的参数是-n，-c的意思是同时把依赖它的包也卸载掉 总结一下 对于a-b-c这样一条依赖树且a和b都是作为依赖安装的， 那么如果使用-R、-Rs去卸载b就会报错提示c的依赖被破坏并中断操作， 使用-Rdd卸载b就会强行删b，同时a和c被保留。 使用-Rc卸b就会把b和c卸载掉，用-Rsc卸b就会把abc全卸掉]]></content>
      <categories>
        <category>arch</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
