<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="theme-color" content="#3b3e43"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no"/><title>操作系统之进程线程 - Kosmos</title><meta name="description" content="本文采用复习拷贝重新阅读大法 本文来自该仓库 进程与线程 1. 进程 进程是资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指 对 PCB 的操作。 一般来说,操作系统的操作中都是对于数据体的操作(似乎是废话) 下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。 并发执行,多个程序可以在一段时间内交替运行,做到类似并行的效果 2. 线程 线程是 独立调度 的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 3. 进程与线程的区别 Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 &gt;进程拥有资源,线程不拥有,线程属于进程,所以可以访问进程的资源 Ⅱ 调度 线程是 独立调度 的基本单位，...."/><meta property="og:description" content="本文采用复习拷贝重新阅读大法 本文来自该仓库 进程与线程 1. 进程 进程是资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指 对 PCB 的操作。 一般来说,操作系统的操作中都是对于数据体的操作(似乎是废话) 下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。 并发执行,多个程序可以在一段时间内交替运行,做到类似并行的效果 2. 线程 线程是 独立调度 的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 3. 进程与线程的区别 Ⅰ 拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 &gt;进程拥有资源,线程不拥有,线程属于进程,所以可以访问进程的资源 Ⅱ 调度 线程是 独立调度 的基本单位，...."/>    <meta name="keywords" content="开源,开发者,笔记,kosmos"/><link rel="dns-prefetch" href="https://ellenbboe.github.io"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://ellenbboe.github.io"><link rel="icon" type="image/png" href="https://s2.ax1x.com/2020/01/12/loApPe.png"/><link rel="apple-touch-icon" href="https://s2.ax1x.com/2020/01/12/loApPe.png"><link rel="shortcut icon" type="image/x-icon" href="https://s2.ax1x.com/2020/01/12/loApPe.png"><meta name="copyright" content="B3log"/><meta http-equiv="Window-target" content="_top"/><meta property="og:locale" content="zh_CN"/><meta property="og:title" content="操作系统之进程线程 - Kosmos"/><meta property="og:site_name" content="Kosmos"/><meta property="og:url"      content="https://ellenbboe.github.io/articles/2019/04/07/1561009683315.html?"/><meta property="og:image" content="https://s2.ax1x.com/2020/01/12/loApPe.png"/><link rel="search" type="application/opensearchdescription+xml" title="操作系统之进程线程 - Kosmos" href="/opensearch.xml"><link href="https://ellenbboe.github.io/rss.xml" title="RSS" type="application/rss+xml" rel="alternate"/><link rel="manifest" href="https://ellenbboe.github.io/manifest.json">        <link rel="canonical" href="https://ellenbboe.github.io/articles/2019/04/07/1561009683315.html">        <link rel="stylesheet"
              href="https://ellenbboe.github.io/skins/Casper/css/base.css?1578931371974"/>
            <link rel="prev" title="操作系统概要" href="https://ellenbboe.github.io/articles/2019/04/07/1561009672302.html">
            <link rel="next" title="剑指offer_Part4" href="https://ellenbboe.github.io/articles/2019/04/09/1561009686522.html">
    </head>
<body class="fn__flex-column">
<div id="pjax" class="fn__flex-1">
    
    <header class="header header--article">
        <div class="wrapper header__title">
            <h1 class="header__h1 fn__flex-inline">
                <img src="https://s2.ax1x.com/2020/01/12/loApPe.png">
                <a href="https://ellenbboe.github.io" rel="start" class="header__title">Kosmos</a>
            </h1>
            <h2 class="header__h2">---就算是痛苦难受，也要去体会那被称为生存的分量---</h2>
        </div>
        <nav class="wrapper header__nav fn__clear">
            <a href="https://ellenbboe.github.io" rel="start">
                    Kosmos
            </a>

                <a class="fn__flex-inline" href="/my-github-repos" target="_self" rel="section">
                    <img src="/images/github-icon.png"> 我的开源
                </a>
                <a class="fn__flex-inline" href="/readlist" target="_self" rel="section">
                     阅读列表
                </a>


            <div class="fn__right">
    <a href="https://hacpai.com/member/ellenbboe"
       title="https://hacpai.com/member/ellenbboe"
       class="user__site"
       target="_blank" rel="noopener nofollow">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path fill="#d23f31" style="fill: var(--color1, #d23f31)" d="M5.787 17.226h17.033l5.954 9.528c0.47 0.752 0.003 1.361-1.042 1.361h-15.141z"></path>
            <path d="M10.74 3.927h17.033c1.045 0 1.512 0.609 1.042 1.361l-5.954 9.528h-19.872l6.379-10.209c0.235-0.376 0.849-0.681 1.372-0.681z"></path>
            <path d="M2.953 17.226h2.839l6.804 10.889h-1.892c-0.523 0-1.137-0.305-1.372-0.681z"></path>
        </svg>
    </a>

        <a href="https://github.com/ellenbboe"
           title="https://github.com/ellenbboe"
           class="user__site"
           target="_blank" rel="noopener nofollow">
            <svg viewBox="0 0 32 32" width="100%" height="100%">
                <path d="M16 0.331c-8.836 0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182 0.8 0.148 1.094-0.347 1.094-0.77 0-0.381-0.015-1.642-0.022-2.979-4.452 0.968-5.391-1.888-5.391-1.888-0.728-1.849-1.776-2.341-1.776-2.341-1.452-0.993 0.11-0.973 0.11-0.973 1.606 0.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33 0.143-1.034 0.558-1.74 1.016-2.14-3.554-0.404-7.29-1.777-7.29-7.907 0-1.747 0.625-3.174 1.649-4.295-0.166-0.403-0.714-2.030 0.155-4.234 0 0 1.344-0.43 4.401 1.64 1.276-0.355 2.645-0.532 4.005-0.539 1.359 0.006 2.729 0.184 4.008 0.539 3.054-2.070 4.395-1.64 4.395-1.64 0.871 2.204 0.323 3.831 0.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295 0 6.145-3.743 7.498-7.306 7.895 0.574 0.497 1.085 1.47 1.085 2.963 0 2.141-0.019 3.864-0.019 4.391 0 0.426 0.288 0.925 1.099 0.768 6.354-2.118 10.933-8.113 10.933-15.18 0-8.837-7.164-16-16-16z"></path>
            </svg>
        </a>

                <a rel="alternate" href="https://ellenbboe.github.io/rss.xml">
                    RSS
                </a>

            </div>
        </nav>
    </header>
    <div class="article__top">
        <div class="fn__clear">
            <div class="toc fn__none" onclick="$('.post__toc').slideToggle()">目录</div>
            <div class="title fn__pointer" onclick="Util.goTop()">操作系统之进程线程</div>
<div class="article__share"
     data-title="操作系统之进程线程"
     data-blogtitle="Kosmos"
     data-url="https://ellenbboe.github.io/articles/2019/04/07/1561009683315.html"
     data-avatar="https://img.hacpai.com/avatar/1560335521987_1576387741689.jpeg?imageView2/1/w/128/h/128/interlace/0/q/100">
    <span class="item" data-type="qqz">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M22.824 13.989l-8.348 6.287s3.351 0.522 8.404 0.461l-0.23-1.040 7.2-6.549c0.132-0.12 0.183-0.312 0.129-0.487s-0.203-0.299-0.377-0.314l-9.492-0.856-3.708-9.213c-0.068-0.169-0.226-0.279-0.401-0.279s-0.333 0.11-0.401 0.279l-3.708 9.213-9.492 0.856c-0.174 0.015-0.323 0.139-0.377 0.314s-0.004 0.366 0.129 0.487l7.2 6.549-2.158 9.742c-0.040 0.178 0.026 0.365 0.168 0.474 0.142 0.107 0.331 0.115 0.481 0.021l8.158-5.165 8.158 5.165c0.070 0.045 0.147 0.066 0.225 0.066 0.090 0 0.18-0.029 0.256-0.086 0.142-0.109 0.208-0.295 0.168-0.474l-1.707-7.704c0.732-0.386 1.538-1.040 1.538-1.040s-3.195 1.638-14.664 0.838l8.312-6.325s-0.327-0.534-10.744-0.914c-0.697-0.026 8.493-1.83 15.281-0.305z"></path>
        </svg>
    </span>
    <span class="item" data-type="wechat">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M9.062 9.203c0-0.859-0.562-1.422-1.422-1.422-0.844 0-1.703 0.562-1.703 1.422 0 0.844 0.859 1.406 1.703 1.406 0.859 0 1.422-0.562 1.422-1.406zM20.672 17.125c0-0.562-0.562-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.859 0 1.422-0.562 1.422-1.141zM16.984 9.203c0-0.859-0.562-1.422-1.406-1.422-0.859 0-1.703 0.562-1.703 1.422 0 0.844 0.844 1.406 1.703 1.406 0.844 0 1.406-0.562 1.406-1.406zM26.906 17.125c0-0.562-0.578-1.125-1.422-1.125-0.562 0-1.125 0.562-1.125 1.125 0 0.578 0.562 1.141 1.125 1.141 0.844 0 1.422-0.562 1.422-1.141zM22.75 10.922c-0.359-0.047-0.719-0.063-1.094-0.063-5.375 0-9.625 4.016-9.625 8.953 0 0.828 0.125 1.625 0.359 2.375-0.359 0.031-0.703 0.047-1.063 0.047-1.422 0-2.547-0.281-3.969-0.562l-3.953 1.984 1.125-3.406c-2.828-1.984-4.531-4.547-4.531-7.656 0-5.391 5.094-9.625 11.328-9.625 5.563 0 10.453 3.391 11.422 7.953zM32 19.687c0 2.547-1.688 4.813-3.969 6.516l0.859 2.828-3.109-1.703c-1.141 0.281-2.281 0.578-3.406 0.578-5.391 0-9.625-3.688-9.625-8.219s4.234-8.219 9.625-8.219c5.094 0 9.625 3.688 9.625 8.219z"></path>
        </svg>
    </span>
    <span class="item" data-type="weibo">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M13.444 27.064c-5.3 0.525-9.875-1.875-10.219-5.35-0.344-3.481 3.675-6.719 8.969-7.244 5.3-0.525 9.875 1.875 10.212 5.35 0.35 3.481-3.669 6.725-8.963 7.244zM24.038 15.521c-0.45-0.137-0.762-0.225-0.525-0.819 0.512-1.287 0.563-2.394 0.006-3.188-1.038-1.481-3.881-1.406-7.137-0.037 0 0-1.025 0.444-0.762-0.363 0.5-1.613 0.425-2.956-0.356-3.737-1.769-1.769-6.469 0.069-10.5 4.1-3.013 3.006-4.763 6.212-4.763 8.981 0 5.287 6.787 8.506 13.425 8.506 8.7 0 14.494-5.056 14.494-9.069 0-2.431-2.044-3.806-3.881-4.375z"></path>
            <path d="M29.819 5.833c-2.1-2.331-5.2-3.219-8.063-2.612v0c-0.663 0.144-1.081 0.794-0.938 1.45 0.144 0.662 0.788 1.081 1.45 0.938 2.038-0.431 4.238 0.2 5.731 1.856s1.9 3.913 1.256 5.888v0c-0.206 0.644 0.144 1.331 0.788 1.544 0.644 0.206 1.331-0.144 1.544-0.787v-0.006c0.9-2.762 0.331-5.938-1.769-8.269z"></path>
            <path d="M26.588 8.752c-1.025-1.138-2.538-1.569-3.925-1.269-0.569 0.119-0.931 0.688-0.813 1.256 0.125 0.569 0.688 0.931 1.25 0.806v0c0.681-0.144 1.419 0.069 1.919 0.619 0.5 0.556 0.637 1.313 0.419 1.975v0c-0.175 0.55 0.125 1.15 0.681 1.331 0.556 0.175 1.15-0.125 1.331-0.681 0.438-1.356 0.163-2.906-0.863-4.037z"></path>
            <path d="M13.738 20.771c-0.188 0.319-0.594 0.469-0.912 0.337-0.319-0.125-0.412-0.488-0.231-0.794 0.188-0.306 0.581-0.456 0.894-0.337 0.313 0.113 0.425 0.469 0.25 0.794zM12.044 22.933c-0.512 0.819-1.613 1.175-2.438 0.8-0.813-0.369-1.056-1.319-0.544-2.119 0.506-0.794 1.569-1.15 2.388-0.806 0.831 0.356 1.1 1.3 0.594 2.125zM13.969 17.146c-2.519-0.656-5.369 0.6-6.463 2.819-1.119 2.262-0.037 4.781 2.506 5.606 2.638 0.85 5.75-0.456 6.831-2.894 1.069-2.394-0.262-4.85-2.875-5.531z"></path>
        </svg>
    </span>
    <span class="item" data-type="twitter">
        <svg viewBox="0 0 32 32" width="100%" height="100%">
            <path d="M32.003 6.075c-1.175 0.525-2.444 0.875-3.769 1.031 1.356-0.813 2.394-2.1 2.887-3.631-1.269 0.75-2.675 1.3-4.169 1.594-1.2-1.275-2.906-2.069-4.794-2.069-3.625 0-6.563 2.938-6.563 6.563 0 0.512 0.056 1.012 0.169 1.494-5.456-0.275-10.294-2.888-13.531-6.862-0.563 0.969-0.887 2.1-0.887 3.3 0 2.275 1.156 4.287 2.919 5.463-1.075-0.031-2.087-0.331-2.975-0.819 0 0.025 0 0.056 0 0.081 0 3.181 2.263 5.838 5.269 6.437-0.55 0.15-1.131 0.231-1.731 0.231-0.425 0-0.831-0.044-1.237-0.119 0.838 2.606 3.263 4.506 6.131 4.563-2.25 1.762-5.075 2.813-8.156 2.813-0.531 0-1.050-0.031-1.569-0.094 2.913 1.869 6.362 2.95 10.069 2.95 12.075 0 18.681-10.006 18.681-18.681 0-0.287-0.006-0.569-0.019-0.85 1.281-0.919 2.394-2.075 3.275-3.394z"></path>
        </svg>
    </span>
    <span class="item__qr"></span>
</div>        </div>
        <progress class="article__progress"></progress>
    </div>
    <div class="article">
        <div class="ft__center">
            <div class="item__meta">
                <time>
                    2019-04-07
                </time>
                /
                    <a class="tag" rel="tag"
                       href="https://ellenbboe.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a> &nbsp;
            </div>
            <h2 class="item__title">
                操作系统之进程线程
            </h2>
        </div>
        <div class="item__cover" style="background-image: url(https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/a6ac2b08-3861-4e85-baa8-382287bfee9f.png)"></div>
        <div class="wrapper">
            <section class="item__content item__content--article vditor-reset">
                <p>本文采用复习拷贝重新阅读大法<br>
本文来自该<a href="https://github.com/CyC2018/CS-Notes" target="_blank">仓库</a></p>
<h1 id="b3_solo_h1_0">进程与线程</h1>
<h2 id="b3_solo_h2_1">1. 进程</h2>
<p>进程是资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指 <strong>对 PCB 的操作</strong>。</p>
<blockquote>
<p>一般来说,操作系统的操作中都是对于数据体的操作(似乎是废话)</p>
</blockquote>
<p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p>
<blockquote>
<p>并发执行,多个程序可以在一段时间内交替运行,做到类似并行的效果</p>
</blockquote>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/a6ac2b08-3861-4e85-baa8-382287bfee9f.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<h2 id="b3_solo_h2_2">2. 线程</h2>
<p>线程是 <strong>独立调度</strong> 的基本单位。</p>
<p>一个进程中可以有多个线程，它们共享进程资源。</p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/3cd630ea-017c-488d-ad1d-732b4efeddf5.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<h2 id="b3_solo_h2_3">3. 进程与线程的区别</h2>
<p>Ⅰ 拥有资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
<blockquote>
<p>进程拥有资源,线程不拥有,线程属于进程,所以可以访问进程的资源</p>
</blockquote>
<p>Ⅱ 调度</p>
<p>线程是 <strong>独立调度</strong> 的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
<blockquote>
<p>进程切换时需要保存当前的cpu环境以及为新调度进程cpu环境的设置</p>
</blockquote>
<p>Ⅲ 系统开销</p>
<p>由于创建或撤销进程时，系统都要为之<strong>分配或回收资源</strong>，如<strong>内存空间</strong>、<strong>I/O 设备</strong> 等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行<strong>进程切换</strong>时，涉及<strong>当前执行进程 CPU 环境的保存</strong>及<strong>新调度进程 CPU 环境的设置</strong>，而线程切换时<strong>只需保存和设置少量寄存器内容</strong>，开销很小。</p>
<blockquote>
<p>线程的创建和撤销的开销远大于进程的开销</p>
</blockquote>
<p>Ⅳ 通信方面</p>
<p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(进程间通信)。</p>
<blockquote>
<p>线程是因为在同一个用户空间里所以可以通信</p>
</blockquote>
<blockquote>
<p>进程的用户空间时相互独立的,一般来说时不能访问的,唯一的例外是共享内存区 进程间通信主要包括管道, 系统IPC（包括消息队列,信号,共享存储), 套接字(SOCKET)(来自百度百科)</p>
</blockquote>
<blockquote>
<p>进程间通信是一组编程接口，让程序员能够协调不同的进程，使之能在一个操作系统里同时运行，并相互传递、交换信息。这使得一个程序能够在同一时间里处理许多用户的要求。因为即使只有一个用户发出要求，也可能导致一个操作系统中多个进程的运行，进程之间必须互相通话(来自百度百科)</p>
</blockquote>
<h1 id="b3_solo_h1_4">进程状态的切换</h1>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/ProcessState.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100" width="500"> </div><br>
<ul>
<li>就绪状态（ready）：等待被调度</li>
<li>运行状态（running）</li>
<li>阻塞状态（waiting）：等待资源</li>
</ul>
<p>应该注意以下内容：</p>
<ul>
<li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li>
</ul>
<h1 id="b3_solo_h1_5">进程调度算法</h1>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="b3_solo_h2_6">1. 批处理系统</h2>
<p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是<strong>保证吞吐量</strong>和<strong>周转时间</strong>（从提交到终止的时间）。</p>
<p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p>
<p>按照请求的顺序进行调度。</p>
<p>有利于<strong>长作业</strong>，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p>
<p>按估计运行时间最短的顺序进行调度。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p>
<p>按估计剩余时间最短的顺序进行调度。</p>
<blockquote>
<p>当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式可以使新的短作业获得良好的服务</p>
</blockquote>
<h2 id="b3_solo_h2_7">2. 交互式系统</h2>
<p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p>
<p><strong>2.1 时间片轮转</strong></p>
<p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和<strong>时间片的大小</strong>有很大关系：</p>
<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ul>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/8c662999-c16c-481c-9f40-1fdba5bc9167.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<p><strong>2.2 优先级调度</strong></p>
<p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了<strong>防止低优先级的进程永远等不到调度</strong>，可以随着<strong>时间的推移增加等待进程的优先级</strong>。</p>
<p><strong>2.3 多级反馈队列</strong></p>
<p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<blockquote>
<p>之后来的程序都先进入diiyige队列,在第一个队列中没有完成执行的会被放到第二个队列中等待,只有到第一个队列为空的时候才会去执行第二个队列中的进程</p>
</blockquote>
<h2 id="b3_solo_h2_8">3. 实时系统</h2>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h1 id="b3_solo_h1_9">进程同步</h1>
<h2 id="b3_solo_h2_10">1. 临界区</h2>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<pre><code class="language-html">// entry section
// critical section;
// exit section
</code></pre>
<h2 id="b3_solo_h2_11">2. 同步与互斥</h2>
<ul>
<li>同步：多个进程按一定顺序执行；</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h2 id="b3_solo_h2_12">3. 信号量</h2>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<blockquote>
<p>pv原语</p>
</blockquote>
<ul>
<li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<pre><code class="language-c">typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&amp;mutex);
    // 临界区
    up(&amp;mutex);
}

void P2() {
    down(&amp;mutex);
    // 临界区
    up(&amp;mutex);
}
</code></pre>
<p><font size="3">  <strong>使用信号量实现生产者-消费者问题</strong>  </font> <br></p>
<p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p>
<p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p>
<pre><code class="language-c">#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&amp;empty);
        down(&amp;mutex);
        insert_item(item);
        up(&amp;mutex);
        up(&amp;full);
    }
}

void consumer() {
    while(TRUE) {
        down(&amp;full);
        down(&amp;mutex);
        int item = remove_item();
        consume_item(item);
        up(&amp;mutex);
        up(&amp;empty);
    }
}
</code></pre>
<blockquote>
<p>先获得信号量的支持,然后在对缓存区进程操作</p>
</blockquote>
<h2 id="b3_solo_h2_13">4. 管程</h2>
<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<pre><code class="language-pascal">monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
</code></pre>
<p>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</strong></p>
<p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><font size="3"> <strong>使用管程实现生产者-消费者问题</strong> </font><br></p>
<pre><code class="language-pascal">// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
</code></pre>
<blockquote>
<p>使用wait()来阻塞自己,直到另外的进程signal()了之后才继续运行</p>
</blockquote>
<h1 id="b3_solo_h1_14">经典同步问题</h1>
<p>生产者和消费者问题前面已经讨论过了。</p>
<h2 id="b3_solo_h2_15">1. 读者-写者问题</h2>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code class="language-c">typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);
        read();
        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);
        up(&amp;count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&amp;data_mutex);
        write();
        up(&amp;data_mutex);
    }
}
</code></pre>
<p>以下内容由 <a href="https://github.com/yugandharbandi" target="_blank">@Bandi Yugandhar</a> 提供。</p>
<p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p>
<pre><code class="language-source-c">int readcount, writecount;                   //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

//READER
void reader() {
&lt;ENTRY Section&gt;
 down(&amp;readLock);                 //  reader is trying to enter
 down(&amp;rmutex);                  //   lock to increase readcount
  readcount++;                 
  if (readcount == 1)          
   down(&amp;resource);              //if you are the first reader then lock  the resource
 up(&amp;rmutex);                  //release  for other readers
 up(&amp;readLock);                 //Done with trying to access the resource

&lt;CRITICAL Section&gt;
//reading is performed

&lt;EXIT Section&gt;
 down(&amp;rmutex);                  //reserve exit section - avoids race condition with readers
 readcount--;                       //indicate you're leaving
  if (readcount == 0)          //checks if you are last reader leaving
   up(&amp;resource);              //if last, you must release the locked resource
 up(&amp;rmutex);                  //release exit section for other readers
}

//WRITER
void writer() {
  &lt;ENTRY Section&gt;
  down(&amp;wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                //report yourself as a writer entering
  if (writecount == 1)         //checks if you're first writer
   down(&amp;readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&amp;wmutex);                  //release entry section

&lt;CRITICAL Section&gt;
 down(&amp;resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
 up(&amp;resource);                //release file

&lt;EXIT Section&gt;
  down(&amp;wmutex);                  //reserve exit section
  writecount--;                //indicate you're leaving
  if (writecount == 0)         //checks if you're the last writer
   up(&amp;readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&amp;wmutex);                  //release exit section
}
</code></pre>
<blockquote>
<p>这段代码就是上一段代码的补充,上一段的写的代码只有一点,上面也说了may result Writer to starve,所以他就在这一段代码write()上也加了信号量的控制,可以承受多个write</p>
</blockquote>
<p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p>
<p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p>
<pre><code class="language-source-c">int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{
    down(&amp;serviceQueue);           // wait in line to be servicexs
    // &lt;ENTER&gt;
    down(&amp;resourceAccess);         // request exclusive access to resource
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced

    // &lt;WRITE&gt;
    writeResource();            // writing is performed
    // &lt;/WRITE&gt;

    // &lt;EXIT&gt;
    up(&amp;resourceAccess);         // release resource access for next reader/writer
    // &lt;/EXIT&gt;
}

void reader()
{
    down(&amp;serviceQueue);           // wait in line to be serviced
    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;ENTER&gt;
    if (readCount == 0)         // if there are no readers already reading:
        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced
    up(&amp;readCountAccess);        // release access to readCount

    // &lt;READ&gt;
    readResource();             // reading is performed
    // &lt;/READ&gt;

    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;EXIT&gt;
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&amp;resourceAccess);     // release resource access for all
    // &lt;/EXIT&gt;
    up(&amp;readCountAccess);        // release access to readCount
}

</code></pre>
<blockquote>
<p>这个建了一个请求服务的信号量,可以保证请求的顺序 也就是说当write请求时 他会等前面的读者都读完然后去write 而后面请求的读者要等到writer写完才可以read</p>
</blockquote>
<h2 id="b3_solo_h2_16">2. 哲学家进餐问题</h2>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>
<p>下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p>
<pre><code class="language-c">#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
</code></pre>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<pre><code class="language-c">#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think();
        take_two(i);
        eat();
        put_two(i);
    }
}

void take_two(int i) {
    down(&amp;mutex);
    state[i] = HUNGRY;
    test(i);
    up(&amp;mutex);
    down(&amp;s[i]);
}

void put_two(i) {
    down(&amp;mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&amp;mutex);
}

void test(i) {         // 尝试拿起两把筷子
    if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&amp;s[i]);
    }
}
</code></pre>
<blockquote>
<p>一个人吃饭会堵塞旁边两个人的吃饭进程,所以当旁边两个人要吃饭的时候,会一直卡在down(&amp;s[i]);这儿,请求获取资源,当中间的人吃好了,就把旁边两人的资源还给他们,让他们能吃饭</p>
</blockquote>
<blockquote>
<p>哲学家问题最初由 Dijkstra提出 哲学家就餐问题，当时这个问题确实是用哲学家吃饭来描述的。但是这里不得不说死锁与活锁的区别，死锁不会自行解开，而活锁有可能自行解开，当然理论上如果这个时间是严格相同的，那么这个活锁产生的影响与死锁自然也有很大程度上是相似的。所以哲学家吃饭问题那一块还是需要修正一下。另外，对于这个问题还有一种可行的解决方式就是引入一个调度员，相当于一个服务生或者侍者，当某个哲学家需要吃饭时，就让服务员来调度餐具。(来自issue)</p>
</blockquote>
<blockquote>
<p>锁产生的前提是：假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。</p>
</blockquote>
<h1 id="b3_solo_h1_17">进程通信</h1>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，<strong>为了能够达到进程同步的目的，需要让进程进行通信</strong>，传输一些进程同步所需要的信息。</p>
<h2 id="b3_solo_h2_18">1. 管道</h2>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
int pipe(int fd[2]);
</code></pre>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li>只能在<strong>父子进程</strong>中使用。</li>
</ul>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<h2 id="b3_solo_h2_19">2. FIFO</h2>
<p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p>
<pre><code class="language-c">#include &lt;sys/stat.h&gt;
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
</code></pre>
<p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"> </div><br>
<blockquote>
<ol>
<li><strong>在用open打开FIFO时有可能会阻塞，原因就是当前只有读端或写端存在</strong>。换句话说，如果程序在打开FIFO时指定了只读方式/只写方式，那么该进程对于打开的FIFO来说就是一个读端/写端。如果指定的是读写方式，那么进程既是读端又是写端。<br>
2.<strong>从FIFO中读数据时(用read函数)，如果没有数据，默认是阻塞等待</strong>，直到有数据被写入FIFO。如果read函数返回0，说明该FIFO所有的写端都已关闭，程序要做相应的处理。<strong>向FIFO写入数据时(使用write函数)，如果FIFO有足够空间，write函数会返回写入的字节数；如果空间不够，write函数会阻塞，直到写完为止。</strong> 当所有的读端都关闭时，再向FIFO写数据会出错。内核会向写进程发管道断裂的信号(SIGPIPE), 从而终止该进程。处理的办法有两种：程序以读写方式打开FIFO或是在程序中捕捉SIGPIPE信号，由用户自行处理。<br>
来自<a href="https://blog.csdn.net/qnqanger/article/details/38124273" target="_blank">https://blog.csdn.net/qnqanger/article/details/38124273</a></li>
</ol>
</blockquote>
<h2 id="b3_solo_h2_20">3. 消息队列</h2>
<p>相比于 FIFO，消息队列具有以下优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
</ul>
<blockquote>
<p>看上面</p>
</blockquote>
<ul>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<blockquote>
<p>可以作为中间件,很强大!</p>
</blockquote>
<blockquote>
<p>消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。将比较耗时而且不需要立即生效返回结果的操作，我们把这种操作作为一个消息，放到消息队列中。处理方可以在任何时候去获取并处理这条消息。这里我们只要保证消息的格式不变，消息的发送方和接收处理方都认识这个消息，那么双方就不需要彼此通信，即可以完成一件事。</p>
</blockquote>
<h2 id="b3_solo_h2_21">4. 信号量</h2>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h2 id="b3_solo_h2_22">5. 共享存储</h2>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p>
<p>需要使用信号量用来同步对共享存储的访问。</p>
<p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。</p>
<h2 id="b3_solo_h2_23">6. 套接字</h2>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
                    <div>
                        <hr>
<img alt="今日诗词" src="https://v2.jinrishici.com/one.svg" style="max-width:100%; display: block; margin: 0 auto;">

标题：操作系统之进程线程<br>
作者：<a href="https://ellenbboe.github.io" target="_blank">ellenbboe</a><br>
地址：<a href="https://ellenbboe.github.io/articles/2019/04/07/1561009683315.html" target="_blank">https://ellenbboe.github.io/articles/2019/04/07/1561009683315.html</a><br>
<!-- 签名档内可使用 HTML、JavaScript -->
<br>
                    </div>
            </section>
        </div>
    </div>
        <div class="post__toc">
<ul class="article__toc">
        <li class="toc__h1">
            <a href="#b3_solo_h1_0">进程与线程</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_1">1. 进程</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_2">2. 线程</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_3">3. 进程与线程的区别</a>
        </li>
        <li class="toc__h1">
            <a href="#b3_solo_h1_4">进程状态的切换</a>
        </li>
        <li class="toc__h1">
            <a href="#b3_solo_h1_5">进程调度算法</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_6">1. 批处理系统</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_7">2. 交互式系统</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_8">3. 实时系统</a>
        </li>
        <li class="toc__h1">
            <a href="#b3_solo_h1_9">进程同步</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_10">1. 临界区</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_11">2. 同步与互斥</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_12">3. 信号量</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_13">4. 管程</a>
        </li>
        <li class="toc__h1">
            <a href="#b3_solo_h1_14">经典同步问题</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_15">1. 读者-写者问题</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_16">2. 哲学家进餐问题</a>
        </li>
        <li class="toc__h1">
            <a href="#b3_solo_h1_17">进程通信</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_18">1. 管道</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_19">2. FIFO</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_20">3. 消息队列</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_21">4. 信号量</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_22">5. 共享存储</a>
        </li>
        <li class="toc__h2">
            <a href="#b3_solo_h2_23">6. 套接字</a>
        </li>
</ul>        </div>
<div class="comment">
    <div class="comment__wrapper wrapper">
        <div class="comment__title">
            评论
        </div>
        <textarea rows="3" placeholder="评论内容只能为 2 到 500 个字符！" id="comment"></textarea>

        <ul id="comments">
        </ul>
    </div>
</div>
    <div class="article__bottom">
        <div class="wrapper">
            <div class="fn__flex">
                <div class="item" id="randomArticles"></div>
                <div class="item" id="relevantArticles"></div>
            </div>
        </div>
    </div>
    
</div>
<footer class="footer">
    <div class="wrapper fn__clear">
        <div class="fn__left">
            &copy; 2020
            <a href="https://ellenbboe.github.io">Kosmos</a>
            <a href="http://www.beian.miit.gov.cn/">浙ICP备18045840号-1</a>--------Let's move on
本站已安全运行:
<span id="momk"></span>
<script language=javascript>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("09-10-2018 19:47:57");//建站日期
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(daysold-e_daysold)*-24;
hrsold=Math.floor(e_hrsold);
e_minsold=(hrsold-e_hrsold)*-60;
minsold=Math.floor((hrsold-e_hrsold)*-60);
seconds=Math.floor((minsold-e_minsold)*-60);
momk.innerHTML=daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒" ;
}
show_date_time();
</script>
<style>
#momk{animation:change 10s infinite;font-weight:800; }
@keyframes change{0%{color:#5cb85c;}25%{color:#556bd8;}50%{color:#e40707;}75%{color:#66e616;}100% {color:#67bd31;}}
</style> &nbsp;•&nbsp;
            Powered by <a href="https://solo.b3log.org" target="_blank">Solo</a>
            <br>
            Theme Casper
            <sup>[<a href="https://github.com/TryGhost/Casper" target="_blank">ref</a>]</sup>
            by <a href="http://vanessa.b3log.org" target="_blank">Vanessa</a>
        </div>
        <div class="fn__right">
            <a href="https://ellenbboe.github.io/tags.html" rel="section">
            标签墙
            </a>
            &nbsp;•&nbsp;
            <a href="https://ellenbboe.github.io/archives.html">
            存档
            </a>
            &nbsp;•&nbsp;
            <a rel="archive" href="https://ellenbboe.github.io/links.html">
            友情链接
            </a>
            <br>
            115 文章 &nbsp;
            9 评论 &nbsp;
            <span data-uvstaturl="https://ellenbboe.github.io">11608</span> 浏览 &nbsp;
            4 当前访客
        </div>
    </div>
</footer>

<script type="text/javascript" src="https://ellenbboe.github.io/js/lib/compress/pjax.min.js" charset="utf-8"></script>
<script type="text/javascript" src="https://ellenbboe.github.io/js/common.min.js?1578931371974"
        charset="utf-8"></script>
<script type="text/javascript"
        src="https://ellenbboe.github.io/skins/Casper/js/common.min.js?1578931371974"
        charset="utf-8"></script>
<script src="https://cdn.jsdelivr.net/npm/uvstat@v1.0.4/dist/index.min.js"></script>
<script>
    var Label = {
        servePath: "https://ellenbboe.github.io",
        staticServePath: "https://ellenbboe.github.io",
        luteAvailable: false,
        hljsStyle: 'colorful',
        langLabel: "zh_CN",
        version: "3.7.0",
    }
    Util.init()
</script>


<script type="text/javascript">
    Util.addScript('https://ellenbboe.github.io/js/page.min.js?1578931371974', 'soloPageScript')
    var page = new Page({
        "commentContentCannotEmptyLabel": "评论内容只能为 2 到 500 个字符！",
        "oId": "1561009683315",
        "blogHost": "https://ellenbboe.github.io",
        "randomArticles1Label": "随机阅读：",
        "externalRelevantArticles1Label": "站外相关阅读："
    });
    $(document).ready(function () {
        page.load();
    page.tips.externalRelevantArticlesDisplayCount = "0";
    Skin.initArticle()
    });
</script>

</body>
</html>

<!-- Generated by Latke (https://github.com/88250/latke) in 32ms, 2020/01/14 12:34:57 -->